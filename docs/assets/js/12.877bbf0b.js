(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{130:function(e,t,a){"use strict";a.r(t);var v=a(3),i=Object(v.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"更新器与循环器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新器与循环器","aria-hidden":"true"}},[e._v("#")]),e._v(" 更新器与循环器")]),e._v(" "),a("p",[e._v("这个库中使用的最基本概念是更新器 (Updater). 一个更新器只需实现两个接口: "),a("code",[e._v("update")]),e._v(" 和 "),a("code",[e._v("render")]),e._v(", 它们分别表示一个实例在更新和渲染时调用的钩子函数. 与更新器相对的另一个概念是循环器 (Looping), 它负责按照特定的顺序调用子实例的更新和渲染, 达到管理整个流程的目的. 可以说 Updater 管理了每一个对象的运动状态 (包括但不限于自机, 敌机, 子弹), 而 Looping 负责调控整体的运转和渲染的进行.")]),e._v(" "),a("p",[e._v("下面我们将分别介绍 Updater 和 Looping 两个基类.")]),e._v(" "),a("h3",{attrs:{id:"关于更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于更新策略","aria-hidden":"true"}},[e._v("#")]),e._v(" 关于更新策略")]),e._v(" "),a("p",[e._v("上面的基本概念意味着我们的更新和渲染流程是分离的. 为什么要这么做呢? 在过去的版本曾经尝试过更新和渲染绑定在同一个函数中的做法. 它的一个最显著的负面影响便是渲染性能会影响自身的重绘速率 (比如这一秒屏幕上只有 10 颗子弹, 下一秒突然变成了 100 颗, 导致程序回调性能发生变化). 而这又导致了更新会受到渲染的影响, 从而画不出完美的图形.")]),e._v(" "),a("p",[e._v('而如果我们将更新与渲染分离, 则主循环可以尽可能地与显示器实现垂直同步, 同时副循环负责按照固定的速率 (一般为 60 fps) 进行更新, 遇到掉帧现象时也可以稍微加快循环速度, 进行"补帧"处理. 这也是众多 STG 游戏都采取的策略.')]),e._v(" "),a("h2",{attrs:{id:"更新器-updater"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新器-updater","aria-hidden":"true"}},[e._v("#")]),e._v(" 更新器 (Updater)")]),e._v(" "),a("h3",{attrs:{id:"new-updater"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-updater","aria-hidden":"true"}},[e._v("#")]),e._v(" new Updater()")]),e._v(" "),a("p",[e._v("返回一个 Updater 实例.")]),e._v(" "),a("h3",{attrs:{id:"updater-settask-callback-index-preserve"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updater-settask-callback-index-preserve","aria-hidden":"true"}},[e._v("#")]),e._v(" updater.setTask(callback, index?, preserve?)")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("callback")]),e._v(": 回调函数, 带有一个参数 "),a("code",[e._v("tick")]),e._v(", 表示回调进行时的刻数.")]),e._v(" "),a("li",[a("code",[e._v("index")]),e._v(": 插入任务钩子的位置, 默认为 "),a("code",[e._v("Infinity")]),e._v(", 即全部任务的最后面.")]),e._v(" "),a("li",[a("code",[e._v("preserve")]),e._v(": 执行完毕后是否保留这个任务, 默认为 "),a("code",[e._v("true")]),e._v(".")]),e._v(" "),a("li",[e._v("返回值: 一个正整数 "),a("code",[e._v("id")]),e._v(", 表示当前任务的序号, 可以用于 "),a("code",[e._v("updater.removeTask")]),e._v(".")])]),e._v(" "),a("h3",{attrs:{id:"updater-removetask-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updater-removetask-id","aria-hidden":"true"}},[e._v("#")]),e._v(" updater.removeTask(id?)")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("id")]),e._v(": 要移除的任务 "),a("code",[e._v("id")]),e._v(". 如果在某个钩子内部调用时, 此选项可以省略, 表示任务完成后移除这个任务本身.")])]),e._v(" "),a("h3",{attrs:{id:"updater-settimeout-ticks-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updater-settimeout-ticks-callback","aria-hidden":"true"}},[e._v("#")]),e._v(" updater.setTimeout(ticks, callback)")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("ticks")]),e._v(": 执行该任务前要等待的刻数.")]),e._v(" "),a("li",[a("code",[e._v("callback")]),e._v(": 回调函数, 带有一个参数 "),a("code",[e._v("tick")]),e._v(", 表示回调进行时的刻数.")])]),e._v(" "),a("h3",{attrs:{id:"updater-setinterval-interval-times-offset-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updater-setinterval-interval-times-offset-callback","aria-hidden":"true"}},[e._v("#")]),e._v(" updater.setInterval(interval, times?, offset?, callback)")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("interval")]),e._v(": 两次执行间要等待的刻数.")]),e._v(" "),a("li",[a("code",[e._v("times")]),e._v(": 一共要执行该任务的次数, 默认为 "),a("code",[e._v("Infinity")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("offset")]),e._v(": 执行第一次任务前要额外等待的刻数, 默认为 "),a("code",[e._v("0")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("callback")]),e._v(": 回调函数, 带有两个参数 "),a("code",[e._v("tick")]),e._v(" 和 "),a("code",[e._v("wave")]),e._v(", 分别表示回调进行时的刻数和当前回调是第几次.")])]),e._v(" "),a("h2",{attrs:{id:"循环器-looping"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环器-looping","aria-hidden":"true"}},[e._v("#")]),e._v(" 循环器 (Looping)")]),e._v(" "),a("h3",{attrs:{id:"new-looping-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-looping-options","aria-hidden":"true"}},[e._v("#")]),e._v(" new Looping(options?)")]),e._v(" "),a("p",[e._v("返回一个 Looping 实例. "),a("code",[e._v("options")]),e._v(" 是一个对象, 可以包含下面的属性:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("options.tickRate")]),e._v(": 更新执行的频率, 默认为 "),a("code",[e._v("60")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("options.tickStorage")]),e._v(": 存储更新数据的个数. 这决定了统计数据的样本大小, 默认为 "),a("code",[e._v("60")]),e._v(". (也就是说, 在默认的配置下, 统计得到的帧率和处理落率是由最近 1s 内的更新数据计算得到的.)")]),e._v(" "),a("li",[a("code",[e._v("options.maxInterpolation")]),e._v(": 单次最大补帧数量. 当发生大量掉帧时 (这可能由于电脑性能过低, 更新或渲染负荷过大等原因), 将不会处理超过这个数量的补帧. 默认值为 "),a("code",[e._v("5")]),e._v(".")])]),e._v(" "),a("h3",{attrs:{id:"looping-pause-slient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#looping-pause-slient","aria-hidden":"true"}},[e._v("#")]),e._v(" looping.pause(slient?)")]),e._v(" "),a("h3",{attrs:{id:"looping-resume-slient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#looping-resume-slient","aria-hidden":"true"}},[e._v("#")]),e._v(" looping.resume(slient?)")]),e._v(" "),a("h3",{attrs:{id:"looping-toggle-slient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#looping-toggle-slient","aria-hidden":"true"}},[e._v("#")]),e._v(" looping.toggle(slient?)")]),e._v(" "),a("p",[e._v("停止 / 恢复 / 切换该实例下的更新和渲染.")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("slient")]),e._v(": 是否触发相应的 "),a("code",[e._v("pause")]),e._v(" 或 "),a("code",[e._v("resume")]),e._v(" 事件, 默认为 "),a("code",[e._v("false")]),e._v(".")])]),e._v(" "),a("h3",{attrs:{id:"looping-getstatus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#looping-getstatus","aria-hidden":"true"}},[e._v("#")]),e._v(" looping.getStatus()")]),e._v(" "),a("p",[e._v("获得当前的状态数据. 返回一个 "),a("code",[e._v("LoopingStatus")]),e._v(" 对象, 包含下列属性:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("stat.tickRate")]),e._v(": 当前帧率.")]),e._v(" "),a("li",[a("code",[e._v("stat.dropRate")]),e._v(": 当前处理落率.")])]),e._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("当前的处理落率计算方法可能存在一定的问题, 导致数值偏大.")])])])},[],!1,null,null,null);t.default=i.exports}}]);